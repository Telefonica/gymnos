#
#
#   Keras Mixin
#
#

import os
import keras

from pydoc import locate
from collections.abc import Iterable
from keras.models import load_model
from keras.utils import to_categorical

from ...utils.io_utils import read_from_json


KERAS_CALLBACKS_IDS_TO_MODULES_PATH = os.path.join(os.path.dirname(__file__), "..", "..", "var", "keras",
                                                   "callbacks.json")


class KerasMixin:

    def fit(self, X, y, batch_size=None, epochs=1, verbose=1, callbacks=None, validation_split=0.0, shuffle=True,
            class_weight=None, sample_weight=None, initial_epoch=0, steps_per_epoch=None, validation_steps=None):

        if callbacks is not None:
            callbacks = self.__instantiate_callbacks(callbacks)

        y = self.__convert_to_categorical_if_needed(y)

        history = self.model.fit(X, y, batch_size=batch_size, epochs=epochs, verbose=verbose, callbacks=callbacks,
                                 validation_split=validation_split, shuffle=shuffle, class_weight=class_weight,
                                 sample_weight=sample_weight, initial_epoch=initial_epoch,
                                 steps_per_epoch=steps_per_epoch, validation_steps=validation_steps)

        return history.history

    def __instantiate_callbacks(self, callbacks_config):
        # directory to save artifacts generated by callbacks
        callbacks_artifacts_dir = os.path.join(os.getcwd(), "callbacks")

        keras_callbacks_ids_to_modules = read_from_json(KERAS_CALLBACKS_IDS_TO_MODULES_PATH)

        callbacks = []
        for callback_config in callbacks_config:
            callback_type = callback_config.pop("type")
            CallbackClass = locate(keras_callbacks_ids_to_modules[callback_type])

            callback_artifacts_path = os.path.join(callbacks_artifacts_dir, callback_type)

            if issubclass(CallbackClass, keras.callbacks.TensorBoard):
                os.makedirs(callback_artifacts_path)
                callback_config["logdir"] = callback_artifacts_path
            elif issubclass(CallbackClass, keras.callbacks.ModelCheckpoint):
                os.makedirs(callback_artifacts_path)
                callback_config["filepath"] = os.path.join(callback_artifacts_path, callback_config["filepath"])
            elif issubclass(CallbackClass, keras.callbacks.CSVLogger):
                os.makedirs(callback_artifacts_path)
                callbacks_config["filename"] = os.path.join(callback_artifacts_path, callback_config["filename"])

            callback = CallbackClass(**callback_config)
            callbacks.append(callback)

        return callbacks


    def __convert_to_categorical_if_needed(self, y):
        loss_name = self.model.loss
        if hasattr(loss_name, '__name__'):
            loss_name = loss_name.__name__
        if loss_name == 'categorical_crossentropy' and len(y.shape) != 2:
            y = to_categorical(y)

        return y

    def evaluate(self, X, y):
        y = self.__convert_to_categorical_if_needed(y)
        metrics = self.model.evaluate(X, y)
        if not isinstance(metrics, Iterable):
            metrics = [metrics]
        return dict(zip(self.model.metrics_names, metrics))

    def predict(self, X):
        return self.model.predict(X)

    def save(self, directory):
        self.model.save(os.path.join(directory, "model.h5"))

    def restore(self, directory):
        self.model = load_model(os.path.join(directory, "model.h5"))
